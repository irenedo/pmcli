#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Marathon CLI based on marathonctl written in python
"""
import sys
import os
import termios
import ConfigParser
import requests
import pdb
import json

__author__ = "Iv√°n Renedo"
__copyright__ = "GPL"


def printusage():
    print("""
pmcli <flags...> [action] <args...>
 Actions
    app
       list                      - list all apps
       versions [id]             - list all versions of apps of id
       show [id]                 - show config and status of app of id (latest version)
       show [id] [version]       - show config and status of app of id and version
       create [jsonfile]         - deploy application defined in jsonfile
       update [id] [jsonfile]    - update application id as defined in jsonfile
       [X] update cpu [id] [cpu%]    - update application id to have cpu% of cpu share
       [X] update memory [id] [MB]   - update application id to have MB of memory
       [X] update instances [id] [N] - update application id to have N instances
       restart [id]              - restart app of id
       destroy [id]              - destroy and remove all instances of id

    task
       list               - list all tasks
       list [id]          - list tasks of app of id
       kill [id]          - kill all tasks of app id
       killtask [taskid] - kill task taskid of app id
       queue              - list all queued tasks

    group
       list                        - list all groups
       list [groupid]              - list groups in groupid
       create [jsonfile]           - create a group defined in jsonfile
       [?] update [groupid] [jsonfile] - update group groupid as defined in jsonfile
       destroy [groupid]           - destroy group of groupid

    deploy
       [X] list               - list all active deploys
       [X] destroy [deployid] - cancel deployment of [deployid]

    marathon
       [X] leader   - get the current Marathon leader
       [X] abdicate - force the current leader to relinquish control
       [X] ping     - ping Marathon master host[s]

 Flags
  -c [config file]
  -h [host]
  -u [user:password] (separated by colon)
  -p [profile] (profile used in the config file)
  -f [format]
       human  (simplified columns, default)
       json   (json on one line)
       jsonpp (json pretty printed)
       raw    (the exact response from Marathon)
""")


def getch():
    '''
    Get one character from stdin
    :return: char
    '''
    old_settings = termios.tcgetattr(0)
    new_settings = old_settings[:]
    new_settings[3] &= ~termios.ICANON
    try:
        termios.tcsetattr(0, termios.TCSANOW, new_settings)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(0, termios.TCSANOW, old_settings)
    return ch


def PrintHuman(dictionary, ident = '', braces=1):
    for key, value in dictionary.iteritems():
        if isinstance(value, dict):
            print '%s%s%s%s' % (ident, braces*'[', key, braces*']')
            PrintHuman(value, ident+'  ', braces+1)
        elif isinstance(value, list):
            ndict=0
            for v in value:
                if isinstance(v, dict):
                    ndict += 1
            if ndict:
                print '%s%s' % (ident, key)
                for e in value:
                    if isinstance(e, dict):
                        PrintHuman(e, ident+'  ', braces+1)
                    else:
                         print ident+'%s : %s' %(key, e)
            else:
                print ident+'%s : %s' %(key, value)
        else:
            print ident+'%s : %s' %(key, value)


def getconfig(arguments):
    opts = {'host': ' ', 'authentication': 0, 'username': '', 'password': '', 'outputformat': 'human'}
    configfile = os.path.expanduser("~/.pmcli.cfg")
    if '-c' in arguments:
        idx = arguments.index('-c')
        configfile = arguments[idx+1]

    try:
        f = open(configfile, 'r')
        f.close()
    except (OSError, IOError) as e:
        if e.errno == 2:
            print(u'Config file ' + configfile + u' not found\n')
            sys.exit(2)
        if e.errno == 13:
            print(u'Read permission error in ' + configfile + u'\n')
            sys.exit(2)

    mesosprofile = 'default'
    if '-p' in sys.argv:
        index = sys.argv.index('-p')
        mesosprofile = sys.argv[index+1]
    cfg = ConfigParser.ConfigParser()
    cfg.read(configfile)

    try:
        opts['host'] = cfg.get(mesosprofile, 'host')
        opts['authentication'] = cfg.get(mesosprofile, 'authentication')
        opts['username'] = cfg.get(mesosprofile, 'user')
        opts['password'] = cfg.get(mesosprofile, 'password')
        opts['outputformat'] = cfg.get(mesosprofile, 'format')
    except ConfigParser.NoOptionError as e:
        print(u'Syntax error en configfile-> ' + str(e))
        sys.exit(2)
    except ConfigParser.NoSectionError as e:
        print(u'Profile \"' + mesosprofile + u'\" doesn\'t exists in file ' + configfile)
        sys.exit(2)

    if '-h' in arguments:
        idx = arguments.index('-h')
        opts['host'] = arguments[idx+1]

    if '-u' in arguments:
        idx = arguments.index('-u')
        userpass = arguments[idx+1]
        try:
            opts['username'], opts['password'] = userpass.split(':')
            opts['authentication'] = 1
        except:
            print(u'there was some error reading you username and password.\n '
                  u'Check is in correct \'username:password\' format')
            printusage()
            sys.exit(2)

    if '-f' in arguments:
        idx = arguments.index('-f')
        opts['outputformat'] = arguments[idx+1]
        if opts['outputformat'] not in ['json', 'human', 'jsonpp', 'raw']:
            print(u'Unknown output format [\'json\', \'human\', \'jsonpp\', \'raw\']')
            printusage()
            sys.exit(2)

    return opts


def printoutput(result, outputformat):
    if outputformat == 'json':
        print(result.json())
    elif outputformat == 'jsonpp':
        print(json.dumps(result.json(), indent=2))
    elif outputformat == 'human':
        PrintHuman(result.json())
    elif outputformat == 'raw':
        print(result.text)


def listapps(opts):
    try:
        resp = requests.get('http://' + opts['host'] + ':8080/v2/apps/')
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'])


def listappid(appid, opts):
    try:
        resp = requests.get('http://' + opts['host'] + ':8080/v2/apps/' + appid)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'])
    # If exists 'message' key in the returned dictionary is that the app doesn't exists
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def listappversions(appid, opts):
    try:
        resp = requests.get('http://' + opts['host'] + ':8080/v2/apps/' + appid + '/versions')
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'])


def createapp(filename, opts):
    try:
        content = open(filename,'rb').read()
        resp = requests.post('http://' + opts['host'] + ':8080/v2/apps/', data=content)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    printoutput(resp, opts['outputformat'])


def destroyapp(appid, opts):
    if listappid(appid, opts):
        print(u'Do you really want to destroy ' + appid + u' application? (y/N)')
        chose = getch()
        if chose in ['y','Y']:
            try:
                resp = requests.delete('http://' + opts['host'] + ':8080/v2/apps/' + appid)
            except requests.exceptions.ConnectionError as e:
                print(u'Error connecting to host')
                print(e[0][1])
                sys.exit(2)
            printoutput(resp, opts['outputformat'])
        else:
            sys.exit(2)
    else:
        sys.exit(2)


def restartapp(appid, opts):
    try:
        resp = requests.post('http://' + opts['host'] + ':8080/v2/apps/' + appid + '/restart')
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'])


def updateappid(arg, opts):
    try:
        content = open(arg[2],'rb').read()
        resp = requests.put('http://' + opts['host'] + ':8080/v2/apps/' + arg[1], data=content)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + arg[2] + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + arg[2])
            sys.exit(2)

    printoutput(resp, opts['outputformat'])


# Still don't work
def updateappcpu(arg, opts):
    try:
        resp = requests.get('http://' + opts['host'] + ':8080/v2/apps/' + arg[2])
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    buff = resp.json()
    buff['app']['cpus'] = float(arg[3])
    try:
        pdb.set_trace()
        headers = {'content-type': 'application/json'}
        resp = requests.put('http://' + opts['host'] + ':8080/v2/apps/' + arg[2], data=buff, headers=headers)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'])


# Still don't work
def updateappmemory(arg, opts):
    pass


# Still don't work
def updateappinstances(arg, opts):
    pass


def listtasks(arg, opts):
    if len(arg) == 2:
        try:
            resp = requests.get('http://' + opts['host'] + ':8080/v2/apps/' + arg[1] + '/tasks')
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    else:
        try:
            resp = requests.get('http://' + opts['host'] + ':8080/v2/tasks/')
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    printoutput(resp, opts['outputformat'])


def killtasks(appid, opts):
    if listtasksid(appid, opts):
        print(u'Do you really want to destroy all ' + appid + u' tasks? (y/N)')
        chose = getch()
        if chose in ['y','Y']:
            try:
                resp = requests.delete('http://' + opts['host'] + ':8080/v2/apps/' + appid + '/tasks')
            except requests.exceptions.ConnectionError as e:
                print(u'Error connecting to host')
                print(e[0][1])
                sys.exit(2)
            printoutput(resp, opts['outputformat'])
        else:
            sys.exit(2)
    else:
        sys.exit(2)


def killtask(appid, taskid, opts):
    try:
        resp = requests.delete('http://' + opts['host'] + ':8080/v2/apps/' + appid + '/tasks/' + taskid)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)

    printoutput(resp, opts['outputformat'])


def listqueue(opts):
    try:
        resp = requests.get('http://' + opts['host'] + ':8080/v2/queue/')
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    if resp:
        print("No tasks queued")
    else:
        printoutput(resp, opts['outputformat'])


def listgroups(arg, opts):
    if len(arg) >= 2:
        try:
            resp = requests.get('http://' + opts['host'] + ':8080/v2/groups/' + arg[1])
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    else:
        try:
            resp = requests.get('http://' + opts['host'] + ':8080/v2/groups/')
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    printoutput(resp, opts['outputformat'])
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def creategroup(filename, opts):
    try:
        content = open(filename,'rb').read()
        resp = requests.post('http://' + opts['host'] + ':8080/v2/groups/', data=content)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    printoutput(resp, opts['outputformat'])


def updategroup(arg, opts):
    try:
        content = open(arg[2],'rb').read()
        resp = requests.put('http://' + opts['host'] + ':8080/v2/groups/' + arg[1], data=content)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + arg[2] + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + arg[2])
            sys.exit(2)

    printoutput(resp, opts['outputformat'])


def destroygroup(arg, opts):
    if listgroups(arg, opts):
        print(u'Do you really want to destroy ' + arg[1] + u' group? (y/N)')
        chose = getch()
        if chose in ['y','Y']:
            try:
                resp = requests.delete('http://' + opts['host'] + ':8080/v2/groups/' + arg[1])
            except requests.exceptions.ConnectionError as e:
                print(u'Error connecting to host')
                print(e[0][1])
                sys.exit(2)
            printoutput(resp, opts['outputformat'])
        else:
            sys.exit(2)
    else:
        sys.exit(2)


# MAIN

if len(sys.argv) <= 1:
    print("Incorrect number of arguments")
    printusage()
    sys.exit(2)

options = getconfig(sys.argv)

if 'app' in sys.argv:
    idx = sys.argv.index('app')
    arg = sys.argv[idx+1:]
    if not arg:
        print(u'Action \'app\' has no arguments')
        printusage()
        sys.exit(2)

    if arg[0].lower() == 'list':
        listapps(options)
    elif arg[0].lower() == 'versions':
        try:
            listappversions(arg[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printusage()
            sys.exit(2)
    elif arg[0].lower() == 'show':
        try:
            listappid(arg[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printusage()
            sys.exit(2)
    elif arg[0].lower() == 'create':
        try:
            createapp(arg[1], options)
        except IndexError:
            print(u'You must supply a file name')
            printusage()
            sys.exit(2)
    elif arg[0].lower() == 'update':
        try:
            if arg[1] == 'cpu':
                updateappcpu(arg, options)
            elif arg[1] == 'memory':
                updateappmemory(arg, options)
            elif arg[1] == 'instances':
                updateappinstances(arg, options)
            else:
                updateappid(arg, options)
        except IndexError:
            print(u'Incorrect call to update app')
            printusage()
            sys.exit(2)
    elif arg[0].lower() == 'restart':
        try:
            restartapp(arg[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printusage()
            sys.exit(2)
    elif arg[0].lower() == 'destroy':
        try:
            destroyapp(arg[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printusage()
            sys.exit(2)
    else:
        print(u'No proper argument to \'app\' action detected')
        printusage()
        sys.exit(2)

elif 'task' in sys.argv:
    idx = sys.argv.index('task')
    arg = sys.argv[idx+1:]
    if not arg:
        print(u'Action \'task\' has no arguments')
        printusage()
        sys.exit(2)

    if arg[0].lower() == 'list':
        listtasks(arg, options)
    elif arg[0].lower() == 'kill':
        killtasks(arg[1], options)
    elif arg[0].lower() == 'killtask':
        try:
            killtask(arg[1], arg[2], options)
        except IndexError:
            print(u'You must supply a task id')
            printusage()
            sys.exit(2)
    elif arg[0].lower() == 'queue':
        listqueue(options)
    else:
        print(u'No proper argument to \'task\' action detected')
        printusage()
        sys.exit(2)

elif 'group' in sys.argv:
    idx = sys.argv.index('group')
    arg = sys.argv[idx+1:]
    if not arg:
        print(u'Action \'group\' has no arguments')
        printusage()
        sys.exit(2)

    if arg[0].lower() == 'list':
        listgroups(arg, options)
    elif arg[0].lower() == 'create':
        creategroup(arg[1], options)
    elif arg[0].lower() == 'update':
        updategroup(arg, options)
    elif arg[0].lower() == 'destroy':
        destroygroup(arg, options)
    else:
        print(u'No proper argument to \'group\' action detected')
        printusage()
        sys.exit(2)

elif 'deploy' in sys.argv:
    idx = sys.argv.index('deploy')
    arg = sys.argv[idx+1:]
    if not arg:
        print(u'Action \'deploy\' has no arguments')
        printusage()
        sys.exit(2)

    if arg[0].lower() == 'list':
        pass
    elif arg[0].lower() == 'destroy':
        pass
    else:
        print(u'No proper argument to \'deploy\' action detected')
        printusage()
        sys.exit(2)

elif 'marathon' in sys.argv:
    idx = sys.argv.index('marathon')
    arg = sys.argv[idx+1:]
    if not arg:
        print(u'Action \'marathon\' has no arguments')
        printusage()
        sys.exit(2)

    if arg[0].lower() == 'leader':
        pass
    elif arg[0].lower() == 'abdicate':
        pass
    elif arg[0].lower() == 'pass':
        pass
    else:
        print(u'No proper argument to \'marathon\' action detected')
        printusage()
        sys.exit(2)
else:
    print(u'No proper action detected')
    printusage()
    sys.exit(2)

sys.exit(0)
