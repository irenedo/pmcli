#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Multi-platform Marathon CLI written in python using its REST API
"""
import sys
import os
import termios
import ConfigParser
import requests
import io
import json
import re

__author__ = "Iván Renedo"
__copyright__ = "GPL"


def checkargs(call, number, section):
    """
    Check if call to 'pmcli <call> <arguments>' doesn't exceed the number of arguments
    :param call: list containing the arguments
    :param number: number of arguments the call must have
    :param section: usage section to show
    """
    if len(call[1:]) > number:
        print(u'Syntax error executing \'pmcli ' + call[0] + u'\'')
        printpart(usage[section], 6)
        sys.exit(2)


def printpart(text, indent):
    """
    Prints pmcli usage
    :param text: text to show
    :param indent: Indentation
    :return: text without the first 'ident' characters from every line
    """
    res = u''
    for line in text.split('\n'):
        res = res + line[indent:] + '\n'
    print(res[1:-1].encode('utf-8'))


def printusage(part):
    """
    Prints all pmcli usage
    :param part: dictionary with all pmcli parts
    """
    print(u"""\npmcli <flags...> [section] [action]""")
    for section in part:
        printpart(section, 0)


def getch():
    """
    Get one character from stdin
    :return: char pressed
    """
    old_settings = termios.tcgetattr(0)
    new_settings = old_settings[:]
    new_settings[3] &= ~termios.ICANON
    try:
        termios.tcsetattr(0, termios.TCSANOW, new_settings)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(0, termios.TCSANOW, old_settings)
    return ch


def printhuman(dictionary, ident='', braces=1):
    """
    Prints the result in human readable format
    :param dictionary: output message
    :param ident: indentantion
    :param braces: number of braces to multiple results section
    """
    tempdict = {}
    # Deployment list comes in a list instead a dictionary. Must be converted before printing
    if isinstance(dictionary, list):
        i = 0
        for item in dictionary:
            templist = [item]
            tempdict[item['id']] = templist
            i += 1

    else:
        tempdict = dictionary.copy()

    for key, value in tempdict.iteritems():
        if isinstance(value, dict):
            print('%s%s%s%s' % (ident, braces*'[', key, braces*']'))
            printhuman(value, ident+'  ', braces+1)
        elif isinstance(value, list):
            ndict = 0
            for v in value:
                if isinstance(v, dict):
                    ndict += 1
            if ndict:
                print('%s%s' % (ident, key))
                for e in value:
                    if isinstance(e, dict):
                        printhuman(e, ident+'  ', braces+1)
                    else:
                        print(ident+'%s : %s' % (key, e))
            else:
                print(ident+'%s : %s' % (key, value))
        else:
            print(ident+'%s : %s' % (key, value))


def checkfile(path):
    """
    Checks if a file exists and is readable
    :param path: path to the file
    :return: True if exists and is readable
    """
    try:
        f = open(path, 'r')
        f.close()
    except (OSError, IOError) as e:
        if e.errno == 2:
            print(u'File ' + path.encode('utf-8') + u' not found\n')
            sys.exit(2)
        if e.errno == 13:
            print(u'Read permission error in ' + path.encode('utf-8') + u'\n')
            sys.exit(2)
    return True


def getconfig(arguments, outputtext):
    """
    Gets the arguments options and puts it in the opts dictionary
    :param arguments: arguments used to call pmcli
    :param outputtext: usage text to print output
    """
    # dictionary with all parameters of configuration
    opts = {'host': ' ', 'username': '', 'password': '', 'outputformat': 'jsonpp', 'file': False,
            'outputfile': '', 'port': '8080', 'force': False, 'proxy': '', 'sproxy': '',
            'timeout': 60, 'ssl': '0', 'verifyssl': True, 'cert': '', 'eventsfiltered': {'type': True, 'value': True},
            'filter_type': {'option': '', 'value': ''}, 'filter_event': []}

    if '-usage' in arguments:
        printusage(outputtext)
        sys.exit(0)

    configfile = os.path.expanduser("~/.pmcli.cfg")
    existsconfigfile = False
    # Check if config is in a config file
    if os.path.isfile(configfile):
        existsconfigfile = True
    elif '-c' in arguments:
        index = arguments.index('-c')
        configfile = arguments[index+1]
        existsconfigfile = True

    # config file exists?
    if existsconfigfile:
        if not checkfile(configfile):
            sys.exit(2)
        else:
            # get profile to use with the config file
            mesosprofile = 'default'
            if '-p' in sys.argv:
                index = sys.argv.index('-p')
                mesosprofile = sys.argv[index+1]
            cfg = ConfigParser.ConfigParser()
            cfg.read(configfile)

            # read hostname from config file. Only host field is required
            try:
                opts['host'] = cfg.get(mesosprofile, 'host')
            except ConfigParser.NoOptionError:
                print(u'no \'host\' section found in config file')
                sys.exit(2)
            except ConfigParser.NoSectionError:
                print(u'Profile \"' + mesosprofile.encode('utf-8') + u'\" doesn\'t exist in file ' + configfile)
                sys.exit(2)

            # read the rest options
            try:
                opts['username'] = cfg.get(mesosprofile, 'user')
                opts['password'] = cfg.get(mesosprofile, 'password')
                opts['outputformat'] = cfg.get(mesosprofile, 'format')
                opts['port'] = cfg.get(mesosprofile, 'port')
                opts['proxy'] = cfg.get(mesosprofile, 'proxy')
                opts['sproxy'] = cfg.get(mesosprofile, 'sproxy')
                opts['timeout'] = cfg.get(mesosprofile, 'timeout')
                opts['ssl'] = cfg.get(mesosprofile, 'ssl')
                opts['verifyssl'] = cfg.get(mesosprofile, 'verifyssl')
                opts['cert'] = cfg.get(mesosprofile, 'cert')
                if opts['ssl']:
                    if opts['verifyssl']:
                        if opts['cert'] == '':
                            print(u'Please, provide a certificate file')
                            sys.exit(2)
                        else:
                            checkfile(opts['cert'])
            except ConfigParser.NoOptionError:
                # Whit the rest of option, doesn't matter if not exist
                pass
            except ConfigParser.NoSectionError:
                print(u'Profile \"' + mesosprofile.encode('utf-8') + u'\" doesn\'t exist in file ' + configfile)
                sys.exit(2)

    # Hostname it's the only argument required
    # get hostname from arguments and overrides the config file one in that case
    if '-h' in arguments:
        index = arguments.index('-h')
        opts['host'] = arguments[index+1]
    else:
        if not existsconfigfile:
            print(u'No hostname or config file supplied')
            sys.exit(2)

    # get username and password from arguments and overrides the config file ones in that case
    if '-u' in arguments:
        index = arguments.index('-u')
        userpass = arguments[index+1]
        try:
            opts['username'], opts['password'] = userpass.split(':')
        except:
            print(u'there was some error reading you username and password')
            printpart(outputtext[6], 0)
            sys.exit(2)

    # get output format from arguments and overrides the config file one in that case ...
    if '-f' in arguments:
        index = arguments.index('-f')
        opts['outputformat'] = arguments[index+1]
    # ... and check if the specified input format is correct
    if opts['outputformat'] not in ['json', 'human', 'jsonpp', 'raw']:
        print(u'Unknown output format')
        printpart(outputtext[6], 0)
        sys.exit(2)

    # get output file to write result
    if '-o' in arguments:
        index = arguments.index('-o')
        opts['file'] = True
        opts['outputfile'] = arguments[index+1]

    # get the port number from arguments and overrides the config file one in that case ...
    if '-P' in arguments:
        index = arguments.index('-P')
        opts['port'] = arguments[index+1]
    # ... and check is a number between 1 and 65535
    if not 1 <= float(opts['port']) <= 65535:
        print(u'Wrong port number')
        printpart(outputtext[6], 0)
        sys.exit(2)

    # get the timeout from arguments and overrides the config file one in that case ...
    if '-t' in arguments:
        index = arguments.index('-t')
        opts['timeout'] = arguments[index+1]
    # ... and check if a number between 1 and 120
    if not 1 <= float(opts['timeout']) <= 120:
        print(u'Wrong timeout value')
        printpart(outputtext[6], 0)
        sys.exit(2)

    # get the proxy from arguments and overrides the config file one in that case ...
    if '-x' in arguments:
        index = arguments.index('-x')
        opts['proxy'] = arguments[index+1]
    # ... and check the format is correct: http://[name]:[port]
    if opts['proxy']:
        # regexp to check url format in proxy addresses
        plainurlformat = r'^http://(?:(?:[A-Z0-9\.](?:[A-Z0-9-\.]{0,61}[A-Z0-9\.])?)|' \
                     r'localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' \
                     r'(?::\d+)?(?:/?|[/?]\S+)$'
        if not re.match(plainurlformat, opts['proxy'], re.IGNORECASE):
            print(u'Wrong proxy URL syntax for HTTP proxy')
            printpart(outputtext[6], 0)
            sys.exit(2)

    # get the https proxy from arguments and overrides the config file one in that case ...
    if '-X' in arguments:
        index = arguments.index('-X')
        opts['sproxy'] = arguments[index+1]
    # ... and check the format is correct: https://[name]:[port]
    if opts['sproxy']:
        # regexp to check url format in SSL proxy addresses
        sslurlformat = r'^https://(?:(?:[A-Z0-9\.](?:[A-Z0-9-\.]{0,61}[A-Z0-9\.])?)|' \
                   r'localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' \
                   r'(?::\d+)?(?:/?|[/?]\S+)$'
        if not re.match(sslurlformat, opts['sproxy'], re.IGNORECASE):
            print(u'Wrong proxy URL syntax for HTTPS proxy')
            printpart(outputtext[6], 0)
            sys.exit(2)

    # Check if we must use SSL and overrides the option from file
    if '-S' in arguments:
        opts['ssl'] = True
    else:
        # Check option 'ssl' in config file
        if opts['ssl'] == '1':
            opts['ssl'] = True
        elif opts['ssl'] == '0':
            opts['ssl'] = False
        else:
            print(u'\'ssl\' option in config file must be 1:Enable, 0:Disabled')
            sys.exit(2)

    # get the certificate from arguments and overrides the config file one in that case ...
    usesslfile = False
    if opts['cert']:
        usesslfile = True
    elif '-C' in arguments:
        index = arguments.index('-C')
        opts['cert'] = arguments[index+1]
        usesslfile = True

    if usesslfile:
        # Check if certificate file exists and is readable
        if not checkfile(opts['cert']):
            sys.exit(2)

    # Check if we must not verify SSL and overrides the option from file
    if '-N' in arguments:
        opts['cert'] = False

    # Check if we must force marathon API operations. This option can be only used from command line
    if '-F' in arguments:
        opts['force'] = True

    # Get filter for 'pmcli marathon events'
    if 'events' in arguments:
        filters = ''
        index = arguments.index('events')
        try:
            filters = arguments[index+1]
        except IndexError:
            opts['eventsfiltered']['type'] = False
            opts['eventsfiltered']['value'] = False

        # check if 'marathon events' has a correct argument and store the value for the filter
        if opts['eventsfiltered']['type'] and opts['eventsfiltered']['value']:
            if re.match(r'^e\[[0-9a-zA-Z_\-]+(,[0-9a-zA-Z_\-]+)*\]', filters, ):
                opts['filter_event'] = filters[2:-1].split(',')
                opts['eventsfiltered']['value'] = False
            elif re.match(r'^a\[[0-9a-zA-Z_\-]*:[0-9a-zA-Z_/\.\-]*\]', filters, ):
                opts['filter_type']['option'] = filters.split(':')[0][2:]
                opts['filter_type']['value'] = filters.split(':')[1][:-1]
                opts['eventsfiltered']['type'] = False
            else:
                print(u'Wrong filter type syntax: \'' + filters + u'\'')
                printpart(usage[5], 6)
                sys.exit(2)

    return opts


def parsetext(jsonstring, rawstring, o):
    """
    prints the result json or raw text to the display
    :param jsonstring: string in json format
    :param rawstring: string in raw format
    :param o: option chosen to parse the result
    :return:
    """
    if o == 'json':
        try:
            print(jsonstring)
        except ValueError:
            print(u'Unknown error parsing result')
            sys.exit(2)
    elif o == 'jsonpp':
        try:
            print(json.dumps(jsonstring, indent=2))
        except ValueError:
            print(u'Unknown error parsing result')
            sys.exit(2)
    elif o == 'human':
            printhuman(jsonstring)
    elif o == 'raw':
        print(rawstring)


def printoutput(result, outputformat, tofile, ofile):
    """
    Prints the output from the call to marathon
    :param result: result from the request call
    :param outputformat: format to use to print it
    :param tofile: boolean. Says if the output must be a file
    :param ofile: File to write the result
    """
    if result.status_code == 401:
        print(u'Authorization required or wrong username/password')
        sys.exit(2)

    if result.status_code == 503:
        print(u'Problem accessing to marathon\n' + result.text)
        sys.exit(2)

    if tofile:
        ch = 'y'
        if os.path.isfile(ofile):
            print(u'Output file exists. Do you really want to overwrite it? (y/N)')
            ch = getch()
        if ch not in ['y', 'Y']:
            sys.exit(0)

        try:
            with io.open(ofile, 'w', encoding='utf-8') as f:
                f.write(unicode(json.dumps(result.json(), indent=2, ensure_ascii=False)))
        except IOError as e:
            print(u'Can\'t write output file: ' + e[1])
            sys.exit(2)
    else:
        parsetext(result.json(), result.text, outputformat)


def printerror(error):
    print(u'Error connecting to host')
    try:
        print(error[0][1])
    except IndexError:
        print(error)
    sys.exit(2)


def callapi(verb, uri, opts):
    """
    Makes a call to a given API URL with the guiven options
    :param verb: http verbs
    :param uri: api uri call
    :param opts: options
    :return: response
    """
    resp = ''
    if opts['ssl']:
        proto = 'https://'
    else:
        proto = 'http://'

    f = ''
    if opts['force']:
        f = '?force=true'

    try:
        if verb['verb'] == 'get':
            resp = requests.get(proto + opts['host'] + ':' + opts['port'] + uri + f,
                                auth=(opts['username'], opts['password']),
                                proxies={"http": opts['proxy'], "https": opts['sproxy'], },
                                timeout=float(opts['timeout']),
                                verify=opts['cert'])
        elif verb['verb'] == 'put':
            resp = requests.put(proto + opts['host'] + ':' + opts['port'] + uri + f,
                                data=verb['content'],
                                auth=(opts['username'], opts['password']),
                                proxies={"http": opts['proxy'], "https": opts['sproxy'], },
                                timeout=float(opts['timeout']),
                                verify=opts['cert'])
        elif verb['verb'] == 'post':
            resp = requests.post(proto + opts['host'] + ':' + opts['port'] + uri + f,
                                 data=verb['content'],
                                 auth=(opts['username'], opts['password']),
                                 proxies={"http": opts['proxy'], "https": opts['sproxy'], },
                                 timeout=float(opts['timeout']),
                                 verify=opts['cert'])
        elif verb['verb'] == 'delete':
            resp = requests.delete(proto + opts['host'] + ':' + opts['port'] + uri + f,
                                   auth=(opts['username'], opts['password']),
                                   proxies={"http": opts['proxy'], "https": opts['sproxy'], },
                                   timeout=float(opts['timeout']),
                                   verify=opts['cert'])
        elif verb['verb'] == 'getstream':
            headers = {'Accept': 'text/event-stream'}
            resp = requests.get(proto + opts['host'] + ':' + opts['port'] + '/v2/events',
                                auth=(opts['username'], opts['password']),
                                headers=headers,
                                stream=True,
                                proxies={"http": opts['proxy'], "https": opts['sproxy'], },
                                timeout=float(opts['timeout']),
                                verify=opts['cert'])
        else:
            print(u'unknown http verb')
            sys.exit(2)

    except requests.exceptions.ConnectionError as e:
        printerror(e)

    if resp.status_code == 409:
        print(resp.json()['message'].replace('. Override with the option \'?force=true\'. ', '. '))
        print(u'Force it with \'-F\' switch')
        sys.exit(2)
    return resp


def listapps(opts):
    """
    Lists all current marathon apps.
        GET /v2/apps
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/apps/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listappid(appid, opts):
    """
    Lists an app config by appid.
        GET /v2/apps/{appId}
    :param appid: app Id
    :param opts: options used to connect and print the result
    :return: True if appid exists, False if not
    """
    resp = callapi({'verb': 'get'}, '/v2/apps/' + appid, opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    # If exists 'message' key in the returned dictionary is that the app doesn't exists
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def showversion(appid, versionid, opts):
    """
    Lists an app by its appid.
        GET /v2/apps/{appId}/versions/{version}
    :param appid: app Id
    :param versionid: version Id
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/apps/' + appid + '/versions/' + versionid, opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listappversions(appid, opts):
    """
    Lists all version of the application with appid.
        GET /v2/apps/{appId}/versions
    :param appid: appid
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/apps/' + appid + '/versions', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def createapp(filename, opts):
    """
    Creates a marathon app from a json file and starts it.
        POST /v2/apps
    :param filename: filename with the app description
    :param opts: options used to connect and print the result
    """
    content = u''
    try:
        content = open(filename, 'rb').read()
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    resp = callapi({'verb': 'post', 'content': content}, '/v2/apps/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroyapp(appid, opts):
    """
    Destroys a marathon app with its given appid.
        DELETE /v2/apps/{appId}
    :param appid: app Id
    :param opts: options used to connect and print the result
    :return:
    """
    if listappid(appid, opts):
        print(u'Do you really want to destroy ' + appid + u' application? (y/N)')
        chose = getch()
        if chose in ['y', 'Y']:
            resp = callapi({'verb': 'delete'}, '/v2/apps/' + appid, opts)
            printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
        else:
            sys.exit(0)
    else:
        sys.exit(2)


def restartapp(appid, opts):
    """
    Restarts all marathon tasks of and appid
        POST /v2/apps/{appId}/restart
    :param appid: appid to restart
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'post', 'content': ''}, '/v2/apps/' + appid + '/restart/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def updateappid(appid, jfile, opts):
    """
    Changes config to application with its appid with a json file
        PUT /v2/apps/{appId}
    :param appid: appid of application to update
    :param jfile: json file with the updated configuration of appid
    :param opts: options used to connect and print the result
    """
    content = u''
    try:
        content = open(jfile, 'rb').read()
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + jfile + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + jfile)
            sys.exit(2)
    resp = callapi({'verb': 'put', 'content': content}, '/v2/apps/' + appid,  opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def changeoption(appid, option, value, opts):
    """
    change option 'option' with the value 'value' in the application 'appid'
        PUT /v2/apps/{appId}
    :param appid: application id
    :param option: option to change
    :param value: new value
    :param opts: options used to connect and print the result
    """

    resp = callapi({'verb': 'get'}, '/v2/apps/' + appid,  opts)
    if resp.status_code == 404:
        print(u'Application \'' + appid + u'\' doesn\'t exist')
        sys.exit(2)

    buff = resp.json()['app']
    # remove options not allowed to be changed
    del buff['version']
    del buff['tasks']
    del buff['versionInfo']
    del buff['cmd']
    del buff['id']

    # Check if 'option' exists within the list of application options
    if option not in buff.keys():
        print(u'Unknown option \"' + option.decode('utf-8') + u'\". Accepted values:\n')
        for k in buff.keys():
            print(u'\t\"' + k + u'\"')
        sys.exit(2)

    # try to convert value to float. If 'value' is not float, raise and exception and it's not converted
    try:
        v = float(value)
    except ValueError:
        v = value

    # Confirm change
    print(u'Option: \"' + option + u'\"\nOld value: ' + str(buff[option]).encode('utf-8') +
          u'\nNew Value :' + value.decode('utf-8') + u'\nDo you really want to change it? (y/N)')
    chose = getch()
    if chose not in ['y', 'Y']:
        sys.exit(0)

    buff[option] = v
    resp = callapi({'verb': 'put', 'content': json.dumps(buff)}, '/v2/apps/' + appid,  opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listtasks(opts):
    """
    List all tasks in marathon
        GET /v2/tasks
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/tasks/',  opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listtaskid(appid, opts):
    """
    List all tasks of appid
        GET /v2/apps/{appId}/tasks
    :param appid: Application id
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/apps/' + appid + '/tasks',  opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def killtasks(appid, opts):
    """
    kill all tasks from appid
        DELETE /v2/apps/{appId}/tasks
    :param appid: app id
    :param opts: options used to connect and print the result
    """
    print(u'Do you really want to destroy all tasks from application ' + appid.decode('utf-8') + u'? (y/N)')
    chose = getch()
    if chose in ['y', 'Y']:
        resp = callapi({'verb': 'delete'}, '/v2/apps/' + appid + '/tasks/',  opts)
        printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    else:
        sys.exit(0)


def killtaskid(appid, taskid, opts):
    """
    kill taskid of appid
        DELETE /v2/apps/{appId}/tasks/{taskId}
    :param appid: application Id
    :param taskid: Task Id
    :param opts: options used to connect and print the result
    """
    print(u'Do you really want to destroy task ' + taskid + u' from application ' + appid + u'? (y/N)')
    chose = getch()
    if chose in ['y', 'Y']:
        resp = callapi({'verb': 'delete'}, '/v2/apps/' + appid + '/tasks/' + taskid,  opts)
        printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    else:
        sys.exit(0)


def listqueue(opts):
    """
    List content of teh staging queue
        GET /v2/queue
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/queue/',  opts)
    if not resp.json()['queue']:
        print("No tasks queued")
    else:
        printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def resetdelay(appid, opts):
    """
    The application specific task launch delay can be reset by calling this endpoint
        DELETE /v2/queue/{appId}/delay
    :param appid: appid
    :param opts: options used to connect and print the result
    """
    callapi({'verb': 'delete'}, '/v2/queue/' + appid + '/delay',  opts)


def listgroups(opts):
    """
    Get config of all groups
        GET /v2/groups
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/groups/',  opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listgroupid(groupid, opts):
    """
    lists groupid config
        GET /v2/groups/{groupId}
    :param groupid: groupid to show config
    :param opts: options used to connect and print the result
    :return: True if groupid exists. False if not
    """
    resp = callapi({'verb': 'get'}, '/v2/groups/' + groupid,  opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def creategroup(filename, opts):
    """
    Create a group from a json file
        POST /v2/groups
    :param filename: file with the group's description
    :param opts: options used to connect and print the result
    """
    content = u''
    try:
        content = open(filename, 'rb').read()
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    resp = callapi({'verb': 'post', 'content': content}, '/v2/groups/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def updategroup(groupid, filename, opts):
    """
    Changes configuration of a group from a json file
        PUT /v2/groups/{groupId}
    :param groupid: group id
    :param filename: JSON filename
    :param opts: options used to connect and print the result
    """
    content = u''
    try:
        content = open(filename, 'rb').read()
    except requests.exceptions.ConnectionError as e:
        printerror(e)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    except IndexError:
        print(u'Error calling group update\nSyntax: pmcli group update [groupid] [json file]')
        sys.exit(2)
    resp = callapi({'verb': 'put', 'content': content}, '/v2/groups/' + groupid, opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroygroup(groupid, opts):
    """
    Removes a group
        DELETE /v2/groups/{groupId}
    :param groupid: groupid to delete
    :param opts: options used to connect and print the result
    """
    if listgroupid(groupid, opts):
        print(u'Do you really want to destroy ' + groupid + u' group? (y/N)')
        chose = getch()
        if chose in ['y', 'Y']:
            resp = callapi({'verb': 'delete'}, '/v2/groups/' + groupid, opts)
            printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
        else:
            sys.exit(0)
    else:
        sys.exit(2)


def listdeploys(opts):
    """
    Lists all running deployments
        GET /v2/deployments
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/deployments/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroydeployment(deployid, opts):
    """
    Removes a deployment from its given deploymentId
        DELETE /v2/deployments/{deploymentId}
    :param deployid: deploymentId
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'delete'}, '/v2/deployments/' + deployid, opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listsubscriptions(opts):
    """
    List all event subscriber callback URLs.
        GET /v2/eventSubscriptions
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/eventSubscriptions', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def registersubscription(url, opts):
    """
    Register a callback URL as an event subscriber.
        POST /v2/eventSubscriptions
    :param url: URL to which events should be posted
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/eventSubscriptions', opts)
    if url in resp.json()['callbackUrls']:
        print(url + u' is already registered')
        sys.exit(2)

    resp = callapi({'verb': 'post', 'content': ''}, '/v2/eventSubscriptions' + '?callbackUrl=' + url, opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroysubscription(url, opts):
    """
    Unregister a callback URL from the event subscribers list.
        DELETE /v2/eventSubscriptions
    :param url: URL passed when the event subscription was created.
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/eventSubscriptions', opts)
    if url in resp.json()['callbackUrls']:
        print(u'Do you really want to unregister \'' + url + u'\' ? (y/N)')
        chose = getch()
        if chose not in ['y', 'Y']:
            sys.exit(0)
    else:
        print(u'\'' + url + u'\' is not registered')
        sys.exit(2)

    resp = callapi({'verb': 'delete'}, '/v2/eventSubscriptions' + '?callbackUrl=' + url, opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def getcurrentleader(opts):
    """
    Returns the current marathon's leader host
        GET /v2/leader
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/v2/leader/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def forcerelinquish(opts):
    """
    Forces a marathon leader to relinquish. A new election triggers
        DELETE /v2/leader
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'delete'}, '/v2/leader/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def pingmaster(opts):
    """
    Pings marathon to test if it's alive
        GET /ping
    :param opts: options used to connect
    """
    resp = callapi({'verb': 'get'}, '/ping', opts)
    print(resp.text)


def attachstream(opts):
    """
    Pings marathon to test if it's alive
    :param opts: options used to connect
    """
    oline = {'event': '', 'data': ''}
    resp = ''
    try:
        resp = callapi({'verb': 'getstream'}, '/v2/events', opts)
        try:
            # every event is composed by twi lines: first one begins with "event" and second one with "data"
            e = re.compile(r'^event: .*')
            d = re.compile(r'^data: .*')
            for line in resp.iter_lines(chunk_size=128):
                # check if it's an event
                if e.match(line):
                    # Must by filtered by event name?
                    if opts['eventsfiltered']['type']:
                        # If event is in list of event to filter
                        if line.split(':')[1][1:] in opts['filter_event']:
                            oline['event'] = line
                            oline['data'] = ''
                        # if not is event list to filter, reset both fields
                        else:
                            oline['event'] = ''
                            oline['data'] = ''
                    # If result must not be filtered, show it
                    else:
                        oline['event'] = line
                        oline['data'] = ''
                # check if it's a data line
                if d.match(line):
                    # if we receive a data line without a previous event, reset it
                    if not oline['event']:
                        oline['data'] = ''
                    else:
                        data = line.split("data: ")[1]
                        # Must by filtered by field?
                        if opts['eventsfiltered']['value']:
                            # If data contains the 'option' field and is equal to 'value' in arguments
                            if opts['filter_type']['option'] in json.loads(data).keys() \
                                    and json.loads(data)[opts['filter_type']['option']] == opts['filter_type']['value']:
                                oline['data'] = data
                            # if not, reset both fields
                            else:
                                oline['event'] = ''
                                oline['data'] = ''
                        # If not filtered, store the data line
                        else:
                            oline['data'] = data

                if oline['event'] and oline['data']:
                    print(oline['event'])
                    parsetext(json.loads(oline['data']), oline['data'], opts['outputformat'])
                    oline['event'] = ''
                    oline['data'] = ''

        except KeyboardInterrupt:
            resp.close()
            sys.exit(0)
    except requests.exceptions.ConnectionError as e:
        printerror(e)
    print(resp.text)


def getinfo(opts):
    """
    Gets info about marathon instances
        GET /v2/info
    :param opts: options used to connect and print the result
    :return:
    """
    resp = callapi({'verb': 'get'}, '/v2/info/', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def getmetrics(opts):
    """
    Gets metrics form marathon
        GET /metrics
    :param opts: options used to connect and print the result
    """
    resp = callapi({'verb': 'get'}, '/metrics', opts)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


# Usage parts
app = u"""
    ├─ app
    │    └─┬─ list                            - list all apps
    │      ├─ versions [appid]                - list all versions of \'appid\'
    │      ├─ show [appid]                    - show config and status of \'appid\' (latest version)
    │      ├─ showversion [appid] [versionid] - show config and status of \'appid\' and \'versionid\'
    │      ├─ create [jsonfile]               - deploy application defined in jsonfile
    │      ├─ update [appid] [jsonfile]       - update application \'appid\' as defined in jsonfile
    │      ├─ change [appid] [opt] [value]    - change appid option \'opt\' to \'value\'
    │      ├─ scale [appid] [N]               - Scale application \'appid\' to have N instances
    │      ├─ restart [appid]                 - restart app of \'appid\'
    │      ├─ destroy [appid]                 - destroy and remove all instances of \'appid\'
    │      ├─ queue                           - (v0.7.0 and above) list all queued tasks
    │      └─ reset [appid]                   - (v0.10.0 and above) reset \'appid\' launch delay
    │"""

task = u"""
    ├─ task
    │     └─┬─ list                       - list all tasks
    │       ├─ show [appid]               - list tasks of app of \'appid\'
    │       ├─ kill [appid]               - kill all tasks of \'appid\'
    │       └─ killtask [appid] [taskid]  - kill task \'taskid\' of app \'appid\'"""

group = u"""
    │
    ├─ group (v0.7.0 and above)
    │      └─┬─ list                        - list all groups
    │        ├─ show [groupid]              - list groups in \'groupid\'
    │        ├─ create [jsonfile]           - create a group defined in jsonfile
    │        ├─ update [groupid] [jsonfile] - update \'groupid\' as defined in jsonfile
    │        └─ destroy [groupid]           - destroy group of \'groupid\'"""


deploy = u"""
    │
    ├─ deploy (v0.7.0 and above)
    │       └─┬─ list                - list all active deploys
    │         └─ destroy [deployid]  - cancel deployment of \'deployid\'"""

subs = u"""
    │
    ├─ subs (v0.9.0 and above)
    │     └─┬─ list              - List all event subscriber callback URLs
    │       ├─ register [url]    - Register \'url\' as an event subscriber list
    │       └─ unregister [url]  - Unregister \'url\' from the event subscribers list"""

marathon = u"""
    │
    └─ marathon
              └─┬─ leader          - (v0.7.0 and above) get the current Marathon leader
                ├─ abdicate        - (v0.7.0 and above) force the current leader to relinquish control
                ├─ ping            - ping Marathon master host[s]
                ├─ events [filter] - (v0.9.0 and above) Attach to the events stream (exit with [Ctrl + C])
                │                    filter (optional):   e[[comma separated events]]
                │                                         a[[id]:[value]]
                ├─ info            - (v0.7.0 and above) get info about marathon instance
                └─ metrics         - get marathon metrics"""

flags = u"""
 Flags
  -usage (prints usage)
  -c [config file]
  -h [host]
  -P [port] Marathon port
  -u [user:password] (separated by colon)
  -p [profile] (profile used in the config file)
  -o [output file] (json format. Overrides -f flag)
  -f [format]
       human  (simplified columns)
       json   (json on one line)
       jsonpp (json pretty printed, default)
       raw    (unprocessed reply from Marathon)
  -t [timeout] Timeout for connections
  -x [http proxy] proxy address
  -X [https proxy] SSL proxy address
  -S Use SSL
  -N Do not verify SSL
  -C Certificate file (pem format)
  -F Force operation"""

usage = [app, task, group, deploy, subs, marathon, flags]

# MAIN

if len(sys.argv) <= 1:
    print("Incorrect number of arguments")
    printusage(usage)
    sys.exit(2)

options = getconfig(sys.argv, usage)

if 'app' in sys.argv:
    idx = sys.argv.index('app')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'app\' has no arguments')
        printpart(usage[0], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        checkargs(argum, 0, 0)
        listapps(options)
    elif argum[0].lower() == 'versions':
        checkargs(argum, 1, 0)
        try:
            listappversions(argum[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'show':
        checkargs(argum, 1, 0)
        try:
            listappid(argum[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'showversion':
        checkargs(argum, 2, 0)
        try:
            showversion(argum[1], argum[2], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'create':
        checkargs(argum, 1, 0)
        try:
            createapp(argum[1], options)
        except IndexError:
            print(u'You must supply a file name')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'update':
        checkargs(argum, 2, 0)
        try:
            updateappid(argum[1], argum[2], options)
        except IndexError:
            print(u'Incorrect call to \'app update\'')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'change':
        checkargs(argum, 3, 0)
        try:
            changeoption(argum[1], argum[2], argum[3], options)
        except IndexError:
            print(u'Incorrect call to \'app change\'')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'scale':
        checkargs(argum, 2, 0)
        try:
            changeoption(argum[1], 'instances', argum[2], options)
        except IndexError:
            print(u'Incorrect call to \'app scale\'')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'restart':
        checkargs(argum, 1, 0)
        try:
            restartapp(argum[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'destroy':
        checkargs(argum, 1, 0)
        try:
            destroyapp(argum[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'queue':
        checkargs(argum, 0, 0)
        listqueue(options)
    elif argum[0].lower() == 'reset':
        checkargs(argum, 1, 0)
        try:
            resetdelay(argum[1], options)
        except IndexError:
            print(u'You must supply an application id')
            printpart(usage[0], 6)
            sys.exit(2)

    else:
        print(u'Unknown command \'' + argum[0].lower() + u'\'')
        printpart(usage[0], 6)
        sys.exit(2)

elif 'task' in sys.argv:
    idx = sys.argv.index('task')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'task\' has no arguments')
        printpart(usage[1], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        checkargs(argum, 0, 1)
        listtasks(options)
    elif argum[0].lower() == 'show':
        checkargs(argum, 1, 1)
        try:
            listtaskid(argum[1], options)
        except IndexError:
            print(u'Not enough number of arguments calling \'task show\'')
            printpart(usage[1], 6)
            sys.exit(2)
    elif argum[0].lower() == 'kill':
        checkargs(argum, 1, 1)
        try:
            killtasks(argum[1], options)
        except IndexError:
            print(u'Syntax error')
            printpart(usage[1], 6)
            sys.exit(2)
    elif argum[0].lower() == 'killtask':
        checkargs(argum, 2, 1)
        try:
            killtaskid(argum[1], argum[2], options)
        except IndexError:
            print(u'Syntax error')
            printpart(usage[1], 6)
            sys.exit(2)

    else:
        print(u'Unknown command \'' + argum[0].lower() + u'\'')
        printpart(usage[1], 6)
        sys.exit(2)

elif 'group' in sys.argv:
    idx = sys.argv.index('group')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'group\' has no arguments')
        printpart(usage[2], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        checkargs(argum, 0, 2)
        listgroups(options)
    elif argum[0].lower() == 'show':
        checkargs(argum, 1, 2)
        try:
            listgroupid(argum[1], options)
        except IndexError:
            print(u'Syntax error')
            printpart(usage[2], 6)
            sys.exit(2)
    elif argum[0].lower() == 'create':
        checkargs(argum, 1, 2)
        creategroup(argum[1], options)
    elif argum[0].lower() == 'update':
        checkargs(argum, 2, 2)
        try:
            updategroup(argum[1], argum[2], options)
        except IndexError:
            print(u'Syntax error')
            printpart(usage[2], 6)
            sys.exit(2)
    elif argum[0].lower() == 'destroy':
        checkargs(argum, 1, 2)
        try:
            destroygroup(argum[1], options)
        except IndexError:
            print(u'You must supply a groupid')
            printpart(usage[2], 6)
            sys.exit(2)
    else:
        print(u'Unknown command \'' + argum[0].lower() + u'\'')
        printpart(usage[2], 6)
        sys.exit(2)

elif 'deploy' in sys.argv:
    idx = sys.argv.index('deploy')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'deploy\' has no arguments')
        printpart(usage[3], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        checkargs(argum, 0, 3)
        listdeploys(options)
    elif argum[0].lower() == 'destroy':
        checkargs(argum, 1, 3)
        try:
            destroydeployment(argum[1], options)
        except IndexError:
            print(u'You must supply a deploy id')
            printpart(usage[3], 6)
            sys.exit(2)
    else:
        print(u'Unknown command \'' + argum[0].lower() + u'\'')
        printpart(usage[3], 6)
        sys.exit(2)

elif 'subs' in sys.argv:
    idx = sys.argv.index('subs')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'subs\' has no arguments')
        printpart(usage[4], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        checkargs(argum, 0, 4)
        listsubscriptions(options)
    elif argum[0].lower() == 'register':
        checkargs(argum, 1, 4)
        registersubscription(argum[1], options)
    elif argum[0].lower() == 'unregister':
        checkargs(argum, 1, 4)
        try:
            destroysubscription(argum[1], options)
        except IndexError:
            print(u'You must supply a callback URL')
            printpart(usage[3], 6)
            sys.exit(2)
    else:
        print(u'Unknown command \'' + argum[0].lower() + u'\'')
        printpart(usage[4], 6)
        sys.exit(2)

elif 'marathon' in sys.argv:
    idx = sys.argv.index('marathon')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'marathon\' has no arguments')
        printpart(usage[5], 6)
        sys.exit(2)

    if argum[0].lower() == 'leader':
        checkargs(argum, 0, 5)
        getcurrentleader(options)
    elif argum[0].lower() == 'abdicate':
        checkargs(argum, 0, 5)
        forcerelinquish(options)
    elif argum[0].lower() == 'ping':
        checkargs(argum, 0, 5)
        pingmaster(options)
    elif argum[0].lower() == 'events':
        checkargs(argum, 1, 5)
        attachstream(options)
    elif argum[0].lower() == 'info':
        checkargs(argum, 0, 5)
        getinfo(options)
    elif argum[0].lower() == 'metrics':
        checkargs(argum, 0, 5)
        getmetrics(options)
    else:
        print(u'Unknown command \'' + argum[0].lower() + u'\'')
        printpart(usage[5], 6)
        sys.exit(2)
else:
    print(u'No proper action detected')
    printusage(usage)
    sys.exit(2)

sys.exit(0)
