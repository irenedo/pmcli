#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Marathon CLI based on marathonctl and written in python
"""
import sys
import os
import termios
import ConfigParser
import requests
import io
import json

__author__ = "Iván Renedo"
__copyright__ = "GPL"


def printpart(text, ident):
    """
    Prints pmcli usage
    :param text: text to show
    :param ident: Indentation
    :return: text without the first 'ident' characters from every line
    """
    res = u''
    for line in text.split('\n'):
        res = res + line[ident:] + '\n'
    print(res[1:-1])


def printusage(usage):
    """
    Prints all pmcli usage
    :param usage: dictinary with all pmcli parts
    """
    print(u"""pmcli <flags...> [section] [action]""")
    for section in usage:
        printpart(section, 0)


def getch():
    """
    Get one character from stdin
    :return: char pressed
    """
    old_settings = termios.tcgetattr(0)
    new_settings = old_settings[:]
    new_settings[3] &= ~termios.ICANON
    try:
        termios.tcsetattr(0, termios.TCSANOW, new_settings)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(0, termios.TCSANOW, old_settings)
    return ch


def printhuman(dictionary, ident='', braces=1):
    """
    Prints the result in human readable format
    :param dictionary: output message
    :param ident: indentantion
    :param braces: number of braces to multiple results section
    """
    tempdict = {}
    # Deployment list comes in a list instead a dictionary. Must be converted before printing
    if isinstance(dictionary, list):
        i = 0
        for item in dictionary:
            templist = []
            templist.append(item)
            tempdict[item['id']] = templist
            i += 1

    else:
        tempdict = dictionary.copy()

    for key, value in tempdict.iteritems():
        if isinstance(value, dict):
            print '%s%s%s%s' % (ident, braces*'[', key, braces*']')
            printhuman(value, ident+'  ', braces+1)
        elif isinstance(value, list):
            ndict = 0
            for v in value:
                if isinstance(v, dict):
                    ndict += 1
            if ndict:
                print('%s%s' % (ident, key))
                for e in value:
                    if isinstance(e, dict):
                        printhuman(e, ident+'  ', braces+1)
                    else:
                        print(ident+'%s : %s' % (key, e))
            else:
                print(ident+'%s : %s' % (key, value))
        else:
            print(ident+'%s : %s' % (key, value))


def getconfig(arguments, outputtext):
    """
    Gets the arguments options and puts it in the opts dictionary
    :param arguments: arguments used to call pmcli
    :param outputtext: usage text to print output
    """
    opts = {'host': ' ', 'username': '', 'password': '', 'outputformat': 'human', 'file': False,
            'outputfile': '', 'port': '8080', 'force': False}
    configfile = os.path.expanduser("~/.pmcli.cfg")
    if '-c' in arguments:
        index = arguments.index('-c')
        configfile = arguments[index+1]

    try:
        f = open(configfile, 'r')
        f.close()
    except (OSError, IOError) as e:
        if e.errno == 2:
            print(u'Config file ' + configfile + u' not found\n')
            sys.exit(2)
        if e.errno == 13:
            print(u'Read permission error in ' + configfile + u'\n')
            sys.exit(2)

    mesosprofile = 'default'
    if '-p' in sys.argv:
        index = sys.argv.index('-p')
        mesosprofile = sys.argv[index+1]
    cfg = ConfigParser.ConfigParser()
    cfg.read(configfile)

    try:
        opts['host'] = cfg.get(mesosprofile, 'host')
        opts['username'] = cfg.get(mesosprofile, 'user')
        opts['password'] = cfg.get(mesosprofile, 'password')
        opts['outputformat'] = cfg.get(mesosprofile, 'format')
        opts['port'] = cfg.get(mesosprofile, 'port')
    except ConfigParser.NoOptionError as e:
        print(u'Syntax error en configfile-> ' + str(e))
        sys.exit(2)
    except ConfigParser.NoSectionError:
        print(u'Profile \"' + mesosprofile + u'\" doesn\'t exists in file ' + configfile)
        sys.exit(2)

    if '-h' in arguments:
        index = arguments.index('-h')
        opts['host'] = arguments[index+1]

    if '-u' in arguments:
        index = arguments.index('-u')
        userpass = arguments[index+1]
        try:
            opts['username'], opts['password'] = userpass.split(':')
        except:
            print(u'there was some error reading you username and password')
            printpart(outputtext[5], 0)
            sys.exit(2)

    if '-f' in arguments:
        index = arguments.index('-f')
        opts['outputformat'] = arguments[index+1]
        if opts['outputformat'] not in ['json', 'human', 'jsonpp', 'raw']:
            print(u'Unknown output format')
            printpart(outputtext[5], 0)
            sys.exit(2)

    if '-o' in arguments:
        index = arguments.index('-o')
        opts['file'] = True
        opts['outputfile'] = arguments[index+1]

    if '-P' in arguments:
        index = arguments.index('-P')
        opts['port'] = arguments[index+1]

    if '-F' in arguments:
        opts['force'] = True

    return opts


def printoutput(result, outputformat, tofile, ofile):
    """
    Prints the output from the call to marathon
    :param result: result from the request call
    :param outputformat: format to use to print it
    :param tofile: boolean. Says if the output must be a file
    :param ofile: File to write the result
    """
    if result.status_code == 401:
        print(u'Authorization required or wrong username/password')
        sys.exit(2)

    if tofile:
        ch = ''
        if os.path.isfile(ofile):
            print(u'Output file exists. Do you really want to overwrite it? (y/N)')
            ch = getch()
        if ch not in ['y', 'Y']:
            sys.exit(0)

        try:
            with io.open(ofile, 'w', encoding='utf-8') as f:
                f.write(unicode(json.dumps(result.json(), indent=2, ensure_ascii=False)))
        except IOError as e:
            print(u'Can\'t write output file: ' + e[1])
            sys.exit(2)
    else:
        if outputformat == 'json':
            try:
                print(result.json())
            except ValueError:
                print(u'Unknown error parsing result')
                sys.exit(2)
        elif outputformat == 'jsonpp':
            try:
                print(json.dumps(result.json(), indent=2))
            except ValueError:
                print(u'Unknown error parsing result')
                sys.exit(2)
        elif outputformat == 'human':
                printhuman(result.json())
        elif outputformat == 'raw':
            print(result.text)


def listapps(opts):
    """
    Lists all current marathon apps.
        GET /v2/apps
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listappid(arg, opts):
    """
    Lists an app by its appid.
        GET /v2/apps/{appId}
        GET /v2/apps/{appId}/versions/{version}
    :param arg: if more than 3 arguments: arg[1] -> appid, arg[2] -> version, else show all running tasks from arg[1]
    :param opts: options used to connect and print the result
    :return: True if appid exists, False if not
    """
    if len(arg) >= 3:
        try:
            resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1] +
                                '/versions/' + arg[2], auth=(opts['username'], opts['password']))
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    else:
        try:
            resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1],
                                auth=(opts['username'], opts['password']))
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    # If exists 'message' key in the returned dictionary is that the app doesn't exists
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def listappversions(appid, opts):
    """
    Lists all version of the application with appid.
        GET /v2/apps/{appId}/versions
    :param appid: appid
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + appid + '/versions',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def createapp(filename, opts):
    """
    Creates a marathon app from a json file and starts it.
        POST /v2/apps
    :param filename: filename with the app description
    :param opts: options used to connect and print the result
    """
    try:
        content = open(filename, 'rb').read()
        resp = requests.post('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/', data=content)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroyapp(arg, opts):
    """
    Destroys a marathon app with its given appid.
        DELETE /v2/apps/{appId}
    :param arg: arg[1] -> appid
    :param opts: options used to connect and print the result
    :return:
    """
    if listappid(arg, opts):
        print(u'Do you really want to destroy ' + arg[1] + u' application? (y/N)')
        chose = getch()
        if chose in ['y', 'Y']:
            f = ''
            if opts['force']:
                f = '?force=true'

            try:
                resp = requests.delete('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1] + f,
                                       auth=(opts['username'], opts['password']))
            except requests.exceptions.ConnectionError as e:
                print(u'Error connecting to host')
                print(e[0][1])
                sys.exit(2)
            printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
        else:
            sys.exit(0)
    else:
        sys.exit(2)


def restartapp(appid, opts):
    """
    Restarts all marathon tasks of and appid
        POST /v2/apps/{appId}/restart
    :param appid: appid to restart
    :param opts: options used to connect and print the result
    """
    f = ''
    if opts['force']:
        f = '?force=true'

    try:
        resp = requests.post('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + appid + '/restart/' + f,
                             auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def updateappid(arg, opts):
    """
    Changes config to application with its appid with a json file
        PUT /v2/apps/{appId}
    :param arg: arg[1] -> appid , arg[2] -> json file
    :param opts: options used to connect and print the result
    """
    f = ''
    if opts['force']:
            f = '?force=true'

    try:
        content = open(arg[2], 'rb').read()
        resp = requests.put('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1] + f, data=content,
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + arg[2] + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + arg[2])
            sys.exit(2)

    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


# Still don't work
def updateappcpu(arg, opts):
    f = ''
    if opts['force']:
            f = '?force=true'

    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[2] + f,
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    buff = resp.json()
    buff['app']['cpus'] = float(arg[3])
    try:
        headers = {'content-type': 'application/json'}
        resp = requests.put('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[2],
                            data=buff, headers=headers)
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


# Still don't work
def updateappmemory(arg, opts):
    pass


# Still don't work
def updateappinstances(arg, opts):
    pass


def listtasks(arg, opts):
    """
    List all tasks in marathon or belonging to an appid.
        GET /v2/apps/{appId}/tasks
        GET /v2/tasks
    :param arg: if more than 2 arguments: arg[1] -> appid, else show all running tasks
    :param opts: options used to connect and print the result
    :return : True if task and app exists, False if not
    """
    if len(arg) >= 2:
        try:
            resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1] + '/tasks')
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    else:
        try:
            resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/tasks/')
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)

    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def killtasks(arg, opts):
    """
    kill application tasks
        DELETE /v2/apps/{appId}/tasks
        DELETE /v2/apps/{appId}/tasks/{taskId}
    :param arg: if more than 3 arguments: arg[1] -> appid, arg[2]-> taskid. Else kill all tasks from arg[1]
    :param opts: options used to connect and print the result
    """
    call = ''
    if len(arg) >= 3:
        # If more than 3 elements in arg, then the order is to kill a taskid from an appid
        if listtasks(arg, opts):
            print(u'Do you really want to destroy task ' + arg[2] + u' from application ' + arg[1] + u'? (y/N)')
            chose = getch()
            if chose in ['y', 'Y']:
                f = ''
                if opts['force']:
                        f = '?force=true'

                call = 'http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1] + '/tasks/' + arg[2] + f
            else:
                sys.exit(0)
    else:
        # If not, the order is to kill all tasks from appid
        if listtasks(arg, opts):
            print(u'Do you really want to destroy all tasks from application ' + arg[1] + u'? (y/N)')
            chose = getch()
            if chose in ['y', 'Y']:
                f = ''
                if opts['force']:
                        f = '?force=true'
                call = 'http://' + opts['host'] + ':' + opts['port'] + '/v2/apps/' + arg[1] + '/tasks/' + f
            else:
                sys.exit(0)
    try:
        resp = requests.delete(call, auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listqueue(opts):
    """
    List content of teh staging queue
        GET /v2/queue
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/queue/',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)

    if not resp:
        print("No tasks queued")
    else:
        printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def listgroups(arg, opts):
    """
    Get all groups config or just one from its groupid depending the arg variable
        GET /v2/groups
        GET /v2/groups/{groupId}
    :param arg: if more than 2 arguments: arg[1] -> appid, else show all running tasks
    :param opts: options used to connect and print the result
    :return: True if groupid exists. False if not
    """
    if len(arg) >= 2:
        try:
            resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/groups/' + arg[1],
                                auth=(opts['username'], opts['password']))
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    else:
        try:
            resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/groups/',
                                auth=(opts['username'], opts['password']))
        except requests.exceptions.ConnectionError as e:
            print(u'Error connecting to host')
            print(e[0][1])
            sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
    if 'message' in resp.json().keys():
        return False
    else:
        return True


def creategroup(filename, opts):
    """
    Create a group from a json file
        POST /v2/groups
    :param filename: file with the group's description
    :param opts: options used to connect and print the result
    """
    try:
        content = open(filename, 'rb').read()
        resp = requests.post('http://' + opts['host'] + ':' + opts['port'] + '/v2/groups/', data=content,
                             auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + filename + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + filename)
            sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def updategroup(arg, opts):
    """
    Changes configuration of a group from a json file
        PUT /v2/groups/{groupId}
    :param arg: arg[1] -> groupid , arg[2] -> filename
    :param opts: options used to connect and print the result
    """
    try:
        content = open(arg[2], 'rb').read()
        f = ''
        if opts['force']:
            f = '?force=true'
        resp = requests.put('http://' + opts['host'] + ':' + opts['port'] + '/v2/groups/' + arg[1] + f, data=content,
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    except IOError as e:
        if e.errno == 2:
            print(u'file name ' + arg[2] + u' not found')
            sys.exit(2)
        if e.errno == 13:
            print(u'No read permission in file ' + arg[2])
            sys.exit(2)
    except IndexError:
        print(u'Error calling group update\nSyntax: pmcli group update [groupid] [json file]')
        sys.exit(2)

    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroygroup(arg, opts):
    """
    Removes a group
        DELETE /v2/groups/{groupId}
    :param arg: groupid to delete
    :param opts: options used to connect and print the result
    """
    if listgroups(arg, opts):
        print(u'Do you really want to destroy ' + arg[1] + u' group? (y/N)')
        chose = getch()
        if chose in ['y', 'Y']:
            f = ''
            if opts['force']:
                    f = '?force=true'
            try:
                resp = requests.delete('http://' + opts['host'] + ':' + opts['port'] + '/v2/groups/' + arg[1] + f,
                                       auth=(opts['username'], opts['password']))
            except requests.exceptions.ConnectionError as e:
                print(u'Error connecting to host')
                print(e[0][1])
                sys.exit(2)
            printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])
        else:
            sys.exit(0)
    else:
        sys.exit(2)


def listdeploys(opts):
    """
    Lists all running deployments
        GET /v2/deployments
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/deployments/',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def destroydeployment(deployid, opts):
    """
    Removes a deployment from its given deploymentId
        DELETE /v2/deployments/{deploymentId}
    :param deployid: deploymentId
    :param opts: options used to connect and print the result
    """
    try:
        f = ''
        if opts['force']:
            f = '?force=true'
        resp = requests.delete('http://' + opts['host'] + ':' + opts['port'] + '/v2/deployments/' + deployid + f,
                               auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)

    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def getcurrentleader(opts):
    """
    Returns the current marathon's leader host
        GET /v2/leader
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/leader/',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def forcerelinquish(opts):
    """
    Forces a marathon leader to relinquish. A new election triggers
        DELETE /v2/leader
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.delete('http://' + opts['host'] + ':' + opts['port'] + '/v2/leader/',
                               auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def pingmaster(opts):
    """
    Pings marathon to test if it's alive
    :param opts: options used to connect
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/ping',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    print(resp.text)


def getinfo(opts):
    """
    Gets info about marathon instances
        GET /v2/info
    :param opts: options used to connect and print the result
    :return:
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/v2/info/',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


def getmetrics(opts):
    """
    Gets metrics form marathon
        GET /metrics
    :param opts: options used to connect and print the result
    """
    try:
        resp = requests.get('http://' + opts['host'] + ':' + opts['port'] + '/metrics',
                            auth=(opts['username'], opts['password']))
    except requests.exceptions.ConnectionError as e:
        print(u'Error connecting to host')
        print(e[0][1])
        sys.exit(2)
    printoutput(resp, opts['outputformat'], opts['file'], opts['outputfile'])


# Usage parts
app = u"""
    ├─ app
    │    └─┬─ list                          - list all apps
    │      ├─ versions [appid]              - list all versions of apps of appid
    │      ├─ show [appid]                  - show config and status of app of appid (latest version)
    │      ├─ show [appid] [version]        - show config and status of app of appid and version
    │      ├─ create [jsonfile]             - deploy application defined in jsonfile
    │      ├─ update [appid] [jsonfile]     - update application appid as defined in jsonfile
    │      ├─ update cpu [appid] [cpu%]     - update application appid to have cpu% of cpu share
    │      ├─ update memory [appid] [MB]    - update application appid to have MB of memory
    │      ├─ update instances [appid] [N]  - update application appid to have N instances
    │      ├─ restart [appid]               - restart app of appid
    │      └─ destroy [appid]               - destroy and remove all instances of appid
    │"""

task = u"""
    ├─ task
    │     └─┬─ list                       - list all tasks
    │       ├─ list [appid]               - list tasks of app of appid
    │       ├─ kill [appid]               - kill all tasks of app appid
    │       ├─ killtask [appid] [taskid]  - kill task taskid of app appid
    │       └─ queue                      - list all queued tasks"""

group = u"""
    │
    ├─ group
    │      └─┬─ list                        - list all groups
    │        ├─ list [groupid]              - list groups in groupid
    │        ├─ create [jsonfile]           - create a group defined in jsonfile
    │        ├─ update [groupid] [jsonfile] - update group groupid as defined in jsonfile
    │        └─ destroy [groupid]           - destroy group of groupid"""


deploy = u"""
    │
    ├─ deploy
    │       └─┬─ list                - list all active deploys
    │         └─ destroy [deployid]  - cancel deployment of [deployid]"""

marathon = u"""
    │
    └─ marathon
              └─┬─ leader    - get the current Marathon leader
                ├─ abdicate  - force the current leader to relinquish control
                ├─ ping      - ping Marathon master host[s]
                ├─ info      - get info about marathon instance
                └─ metrics   - get marathon metrics"""

flags = u"""
 Flags
  -c [config file]
  -h [host]
  -P [port] Marathon port
  -u [user:password] (separated by colon)
  -p [profile] (profile used in the config file)
  -o [output file] (json format. Overrides -f flag)
  -f [format]
       human  (simplified columns)
       json   (json on one line)
       jsonpp (json pretty printed, default)
       raw    (the exact response from Marathon)
  -F Force operation"""

usage = [app, task, group, deploy, marathon, flags]

# MAIN

if len(sys.argv) <= 1:
    print("Incorrect number of arguments")
    printusage(usage)
    sys.exit(2)

options = getconfig(sys.argv, usage)

if 'app' in sys.argv:
    idx = sys.argv.index('app')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'app\' has no arguments')
        printpart(usage[0], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        listapps(options)
    elif argum[0].lower() == 'versions':
        try:
            listappversions(argum[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'show':
            listappid(argum, options)
    elif argum[0].lower() == 'create':
        try:
            createapp(argum[1], options)
        except IndexError:
            print(u'You must supply a file name')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'update':
        try:
            if argum[1] == 'cpu':
                updateappcpu(argum, options)
            elif argum[1] == 'memory':
                updateappmemory(argum, options)
            elif argum[1] == 'instances':
                updateappinstances(argum, options)
            else:
                updateappid(argum, options)
        except IndexError:
            print(u'Incorrect call to update app')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'restart':
        try:
            restartapp(argum[1], options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    elif argum[0].lower() == 'destroy':
        try:
            destroyapp(argum, options)
        except IndexError:
            print(u'You must supply an application index')
            printpart(usage[0], 6)
            sys.exit(2)
    else:
        print(u'No proper argument to \'app\' section detected')
        printpart(usage[0], 6)
        sys.exit(2)

elif 'task' in sys.argv:
    idx = sys.argv.index('task')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'task\' has no arguments')
        printpart(usage[1], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        listtasks(argum, options)
    elif argum[0].lower() == 'kill':
        killtasks(argum, options)
    elif argum[0].lower() == 'queue':
        listqueue(options)
    else:
        print(u'No proper argument to \'task\' section detected')
        printpart(usage[1], 6)
        sys.exit(2)

elif 'group' in sys.argv:
    idx = sys.argv.index('group')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'group\' has no arguments')
        printpart(usage[2], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        listgroups(argum, options)
    elif argum[0].lower() == 'create':
        creategroup(argum[1], options)
    elif argum[0].lower() == 'update':
        updategroup(argum, options)
    elif argum[0].lower() == 'destroy':
        destroygroup(argum, options)
    else:
        print(u'No proper argument to \'group\' section detected')
        printpart(usage[2], 6)
        sys.exit(2)

elif 'deploy' in sys.argv:
    idx = sys.argv.index('deploy')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'deploy\' has no arguments')
        printpart(usage[3], 6)
        sys.exit(2)

    if argum[0].lower() == 'list':
        listdeploys(options)
    elif argum[0].lower() == 'destroy':
        try:
            destroydeployment(argum[1], options)
        except IndexError:
            print(u'You must supply a deploy id')
            printpart(usage[3], 6)
            sys.exit(2)
    else:
        print(u'No proper argument to \'deploy\' section detected')
        printpart(usage[3], 6)
        sys.exit(2)

elif 'marathon' in sys.argv:
    idx = sys.argv.index('marathon')
    argum = sys.argv[idx+1:]
    if not argum:
        print(u'Action \'marathon\' has no arguments')
        printpart(usage[4], 6)
        sys.exit(2)

    if argum[0].lower() == 'leader':
        getcurrentleader(options)
    elif argum[0].lower() == 'abdicate':
        forcerelinquish(options)
    elif argum[0].lower() == 'ping':
        pingmaster(options)
    elif argum[0].lower() == 'info':
        getinfo(options)
    elif argum[0].lower() == 'metrics':
        getmetrics(options)
    else:
        print(u'No proper argument to \'marathon\' section detected')
        printpart(usage[4], 6)
        sys.exit(2)
else:
    print(u'No proper action detected')
    printusage(usage)
    sys.exit(2)

sys.exit(0)
